// 063_Vptr.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
//

//  \|/-

#include <iostream>

//상속을 얼마나 했건 맴버변수가 한개도 없으면 반드시 크기는 1바이트이다.
//virtual이 붙어있는 클래스는 객체가 생성될때 함수포인터 배열을 반들고 그걸 함수포인터의 포인터로 저장
//void(*__vfptr[???])()  <- 이걸 가상함수 Table 이라고 한다. 컴파일러가 알아서 만들어 주므로 신경쓸필요는 없다.
//void(**__vfptr)() = __vfptr

class FightUnit
{
public:
    virtual void Damage()
    {

    }



    FightUnit()
    {

    }

};

class Player : public FightUnit
{


};

class Monster : public FightUnit
{
public:
    virtual void GetAtt()
    {

    }

    virtual void SetAtt()
    {

    }

    virtual void GetHp()
    {

    }

};


int main()
{
    int Value = sizeof(Player); 
    //가상함수가 하나라도 있으면, 그리고 가상함수가 아무리 많아도 함수이중포인터 하나(포인터니까 당연히 8바이트)를 객체에 할당합니다.
    //이 함수이중포인터는 함수포인터배열을 가리키고 있습니다.
    //그 함수포인터 배열들은 또 가상함수를 가리키고 있습니다.
    //즉 함수이중포인터 -> 함수포인터배열 -> 가상함수 순으로 가리킴.
    
    //위 사례에서 알수있듯, 맴버변수 하나도 없으면 문법 끼워 맞추기로 1바이트 할당해준다고 했는데 가상함수 있으면 8바이트 할당해주니까 굳이 또 1바이트 할당 안해줍니다.
    // 그니까 클래스에 맴버변수 없다고 무조건 1바이트 할당하는게 아니라는 것.  함수이중포인터메모리(8바이트) + 맴버변수없는클래스(1바이트) == 9바이트? 오답. 정답은 그냥 8바이트.

    int Value2 = sizeof(Monster);
    //가상함수 아무리 많아도 8바이트. 헷갈리면 안됨 함수이중포인터를 객체의 메모리에 할당하는거지, 함수포인터배열(가상함수테이블)을 객체의 메모리에 할당하는게 아님.
    //함수포인터 배열은 컴파일러가 어딘가에 알아서 만들어 두는거고 우리가 신경쓸게 아님. 중요한건 함수이중포인터만으로도 가상함수를 다 사용가능하다는 문법적 이해를 했느냐가 중요
    

    int a = 0;
}

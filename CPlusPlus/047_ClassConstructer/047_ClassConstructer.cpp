
#include <iostream>

class Player
{
public:

    //리터럴 초기화 - 클래스 선언부의 맴버변수에 초기화를 바로 해줄수있음. 11버전 이전에는 안됬던 방식. 회사마다 사용 안할 수 있음.
    int Hp = 20;
    int Maxatt = 20;
    int Minatt = 20;

    void function()
    {
    }

    //생성자는 이름이 무조건 클래스 이름과 완전히 동일해야한다.
    //생성자는 리턴값이 프로그래머 눈에는 보이진 않지만 Player 객체를 반환한다.
    //생성자는 만들어진 객체 없이 호출할수 있는 예외적인 맴버함수. 
    //생성자는 맴버이니셜라이저를 사용할수 있음
    //리터럴 초기화와 맴버이니셜라이저를 동시에 하면, 맴버이니셜라이저가 나중에 수행되기 때문에 맴버이니셜라이저에서 한 초기화만 남는다.
    Player()
        :Hp(30), Maxatt(30), Minatt(30)
    {
        //생성자 안에도 대입할 수도 있다. 이렇게 되면 맴버이니셜라이저 보다도 나중에 수행되기때문에 대입에서 한 초기화가 최종적으로 남는다.
        Hp = 10;
    }
    //초기화 우선순위 : (생성자 내부에서한)대입연산> 맴버이니셜라이저> 리터럴초기화

};

class Player2
{
 public:
    Player2(int _Value, int _Value1)
    {

    }
};

int main()
{
    //내가 정의하지 않은 행동이 된다면 그건 컴파일러가 수행하고 내눈엔 생략된것.
    Player Test = Player(); // Player() 라는 부분은 내가 안만들었는데 컴파일러가 알아서 구현해준것

    //클래스의 맴버함수는 무조건 만들어진 객체를 통해 호출되야하고 전역함수 처럼 쓰듯이 그냥 사용할 수 없음
    //즉 Player::Function(); 처럼 이용불가
    //그러나 이 제약에서 벗어난 함수가 2종이 있는데 그중 1종이 생성자이다.
    //생성자는 객체를 만들어내는 전역함수역할을 해준다.

    int Value = Test.Hp;

    int a = 0;

    //클래스에 인자가 있으면 인자만 써주고 생성자를 쓰는걸 생략할수있음.
    

     //정석적인 클래스 생성법
    Player2 NewPlayer1 = Player2(20, 30);
    //리스트 이니셜라이저 문법
    Player2 NewPlayer2 = { 20,30 };

   
    
}

